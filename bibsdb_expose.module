<?php
/**
 * @file
 * Code for the Bibsdb Masonry feature.
 */

include_once 'bibsdb_expose.features.inc';

// Alterations to node add/edit form
include_once 'bibsdb_expose.admin.inc';

// Load tag logic
include_once 'bibsdb_expose.tag.inc';

// Load code that generates list images with background effect. 
include_once 'bibsdb_expose.bgimg.inc';
include_once 'bibsdb_expose.theme.inc';



/**
 * Implements hook_entity_info().
 */
function bibsdb_expose_entity_info() {

  $info = array();
  
  $info['exposure'] = array(
    'label' => t('Exposure'),
    'controller class' => 'EntityAPIController',
    'base table' => 'bibsdb_expose_exposures',
    'entity keys' => array(
      'id' => 'id',
      'label' => 'id',
      ),
    'entity class' => 'ExposureEntity',
    'access callback' => 'bibsdb_expose_access_callback',
    'uri callback' => 'entity_class_uri',
    'admin ui' => array(
      'path' => 'admin/exposures',
      'controller class' => 'EntityDefaultUIController',
      ),
    'fieldable' => TRUE,
    'bundles' => array(
      'exposure' => array(
        'label' => t('Exposure'),
        'admin' => array(
          'path' => 'admin/structure/exposure/manage',
          'access arguments' => array('administer exposures'),
          ),
        ),
      ),
    'views controller class' => 'EntityDefaultViewsController',
    'module' => 'bibsdb_expose',
    'view modes' => array(
      'full' => array(
        'label' => t('Full'), 
        'custom settings' => TRUE,
        ),
      ),
    );
  
  return $info;
}

/**
 * Implements hook_menu()
 */
function bibsdb_expose_menu() {
  $items = array();

  $items['admin/structure/exposure/manage'] = array(
    'title' => 'Exposure',
    'description' => 'Manage Exposure structure.',
    'page callback' => 'bibsdb_expose_exposures',
    'access arguments' => array('administer exposures'),
    'file' => 'bibsdb_expose.pages.inc',
    );
  
  $items['exposure/%'] = array(
    'title' => 'Exposure',
    'page callback' => 'bibsdb_expose_view_exposure',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'file' => 'bibsdb_expose.pages.inc',
    );
  
  return $items;
}

function bibsdb_expose_permission(){
  return array(
    'administer exposures' =>  array(
      'title' => t('Administer exposures'),
      'restrict access' => TRUE,
      ),
    );
}

/**
 * Access callback for exposure entities.
 */
function bibsdb_expose_access_callback($op, $exposure = NULL, $account = NULL) {
  if ($op == 'view' || $op == 'update' || $op == 'create' || $op == 'delete') {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Form definition for adding / editing a exposure.
 */
function exposure_form($form, &$form_state, $exposure = NULL) { 

  field_attach_form('exposure', $exposure, $form, $form_state);
  
  $form['submit'] = array(
    '#type' => 'submit', 
    '#value' => isset($exposure->id) ? t('Update exposure') : t('Save exposure'),
    '#weight' => 50,
    );

  return $form;
}

/**
 * Submit handler for the exposure add/edit form.
 */
function exposure_form_submit($form, &$form_state) {
  $exposure = entity_ui_form_submit_build_entity($form, $form_state);
  $exposure->save();
  drupal_set_message(t('The exposure: @name has been saved.', array('@name' => $exposure->id)));
  $form_state['redirect'] = 'admin/exposures';
}

/**
 * Implements hook_entity_property_info().
 */
function bibsdb_expose_entity_property_info() {

  $info = array();
  
  $info['exposure']['properties']['id'] = array(
    'label' => t('Exposure ID'),
    'description' => t('The ID of the exposure.'),
    'type' => 'integer',
    'schema field' => 'id',
    );
  
  return $info;
}

/**
 * Implements hook_theme().
 */
function bibsdb_expose_theme($existing, $type, $theme, $path) {
  return array(
    'exposure' => array(
      'variables' => array('content' => null),
      'template' => 'templates/exposure',
      //'file' => 'bibsdb_expose.theme.inc',
      ),
    'views_view_unformatted__bibsdb_wall' => array(
      'arguments' => array('view' => NULL, 'field' => NULL, 'row' => NULL),
      'template' => 'views-view-unformatted--bibsdb-wall',
      'original hook' => 'views_view_unformatted',
      'path' => drupal_get_path('module', 'bibsdb_expose') . '/templates',
    ),
    );
}

function bibsdb_expose_entity_view($entity, $type, $view_mode, $langcode) {
  if (!($type == 'exposure')) {
    return;
  }

  //Load the linked node
  $exposure_wrapper = entity_metadata_wrapper('exposure', $entity);
  $node_wrapper = $exposure_wrapper->field_bibsdb_brick_content;
  $node = $node_wrapper->value();
  $nodeprops = $node_wrapper->getPropertyInfo();

  //Load the brick type
  $term_wrapper = $exposure_wrapper->field_bibsdb_brick_type;
  $term_name = $term_wrapper->name->value();
  // The term name contains info 4 pieces of info separated by '-'
  // 0. piece: col number
  // 1. piece: The number of cols this element spans
  // 2. piece: The number of rows this element spans
  // 3. piece: The name of a brick design
  // 4. piece: The fields to be output
  // 5. piece: The name of the imagestyle to use
  

  $term_name_elements = explode('-', $term_name);

  // Extract the field list to be output
  $fieldlist = explode('x', $term_name_elements[4]);

  // Modify the col number so it doesn't start with a number
  $colnumber = explode('COL', array_shift($term_name_elements));
  $colclass = "col" . $colnumber[0] . " ";

  $lastchar = substr($term_name_elements[0], -1);



  // Add all the info from term-name as classes
  $entity->content['classes'] .= 'brick ';
  $entity->content['classes'] .= $colclass;
  $entity->content['classes'] .= strtolower(implode(' ', $term_name_elements));


  // This is a config-array that helps us select the same fields in different content type
  // This is nessecary because the fields are named differently in the content types
  $field_selection_settings = array(
    'tag' => array(
      'prefix' => 'field_bibsdb',
      'suffix' => 'tag',
      'view_mode' => 'full',
      'options' => array(),
    ),
    'lead' => array(
      'prefix' => 'field_ding',
      'suffix' => 'lead',
      'view_mode' => 'full',
      'options' => array(),
    ),
    'img' => array(
      'prefix' => 'field_ding',
      'suffix' => 'list_image',
      'view_mode' => 'teaser',
      'options' => array(
        'type' => 'image',
        'settings' => array(
          'image_style' => $term_name_elements[5],
          'image_link' => 'content',
        ),
      ),
    ),
  );

  // Build the render array
  $entity->content['fields'] = array();

  foreach ($fieldlist as $fieldkey) {
    $entity->content['fields'][$fieldkey] = array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array($fieldkey),
      ),
    );

    if($fieldkey == 'title') {
      $entity->content['fields'][$fieldkey]['content'] = array(
        '#type'  => 'link',
        '#title' => $node->title,
        '#href'  => 'node/' . $node->nid,
      );
    }
    else {
      $entity->content['fields'][$fieldkey]['content'] = _build_field($node, $nodeprops, $field_selection_settings[$fieldkey]);
    }
  }
}


/**
 * Exposure entity class extending the Entity class
 */
class ExposureEntity extends Entity {

  /**
   * Change the default URI from default/id to exposure/id
   */
  protected function defaultUri() {
    return array('path' => 'exposure/' . $this->identifier());
  }
  
}


/**
* Helper function that finds a specifik field in an node based on what the maschine field name starts and ends with.
* The field is then output as a rendarable array.
* Todo: Only works for single value fields.
*/
function _build_field($node, $nodeprops, $field_settings) {
  $delta = 0;
  foreach ($nodeprops as $key => $value) {
    if (_starts_with($key, $field_settings['prefix']) && _ends_with($key, $field_settings['suffix'])){
      $field = field_get_items('node', $node, $key);
      // If we are about to shaow an image set the image style
      return field_view_value('node', $node, $key, $field[$delta], $field_settings['options']);
    }
  }
  return array();
}

/** 
* Helper function to determine if a string starts with another string.
*/
function _starts_with($haystack, $needle) {
  // search backwards starting from haystack length characters from the end
  return $needle === "" || strrpos($haystack, $needle, -strlen($haystack)) !== false;
}

/** 
* Helper function to determine if a string ends with another string.
*/
function _ends_with($haystack, $needle) {
  // search forward starting from end minus needle length characters
  return $needle === "" || (($temp = strlen($haystack) - strlen($needle)) >= 0 && strpos($haystack, $needle, $temp) !== false);
}




/**
 * Implements hook_action_info().
 */
function bibsdb_expose_action_info() {
  return array(
    'bibsdb_expose_vbo_expose' => array(
      'type' => 'node',
      'label' => t('Expose content'),
      'configurable' => TRUE,
      'vbo_configurable' => FALSE,
      'triggers' => array('any'),
      ),
    );
}

function bibsdb_expose_vbo_expose_form($settings, &$form_state) {
  // Load brick type vocabulary
  $vocabulary = taxonomy_vocabulary_machine_name_load('bibsdb_brick_type');
  $tree = taxonomy_get_tree($vocabulary->vid, $parent = 0, $max_depth = 1, $load_entities = FALSE);

  // Build select
  $brick_type_options = array();
  foreach ($tree as $term) {
    $brick_type_options[$term->tid] = $term->name;
  }
  // Build form
  $form = array();
  $form['brick_type'] = array(
    '#type' => 'select', 
    '#title' => t('Choose brick type'),
    '#options' => $brick_type_options,
    '#required' => TRUE,
    );

  // Add redirect to return to 
  $view = $settings['view'];
  $wall = $view->args[0];

  return $form;
}

function bibsdb_expose_vbo_expose_submit($form, $form_state) {

  $return = array(); 
  $return['brick_type'] = $form_state['values']['brick_type'];
  return $return; //Note, return value here must be an array.
}

/**
 * VBO action that creates an exposure entity.
 */
function bibsdb_expose_vbo_expose(&$node, $context) {

  $wall = $context['view_info']['arguments']['0'];
  $brick_type = $context['brick_type'];
  $brick_content = $node->nid;

  $entity_type = 'exposure';
  $entity = entity_create($entity_type, array('bundle' => $entity_type));
  $wrapper = entity_metadata_wrapper($entity_type, $entity);
  
  $wrapper->field_bibsdb_wall = $wall;
  $wrapper->field_bibsdb_brick_type = $brick_type;
  $wrapper->field_bibsdb_brick_content = $brick_content;
  $wrapper->save();
}

/**
 * Wrapper function that adds the modules JavaScript.
 */
function _bibsdb_expose_add_javascript() {
  // We will add nothing if our required library is not present. This will have
  // the desired effect of not showing anything to the user. The check could be
  // better integrated in the theme hook, but this will do for now.
  if ($library_path = libraries_get_path('packery')) {
    drupal_add_library('system', 'ui.widget');

    // Use the minified versions.
    $library_path .= '';
    $options = array('group' => JS_LIBRARY);
    drupal_add_js($library_path . '/packery.pkgd.min.js', $options);
  }

  if ($library_path = libraries_get_path('imagesloaded')) {
    drupal_add_library('system', 'ui.widget');

    // Use the minified versions.
    $library_path .= '';
    $options = array('group' => JS_LIBRARY);
    drupal_add_js($library_path . '/imagesloaded.pkgd.min.js', $options);
  }

  // Ad our own JS to control and setup packery.
  $module_path = drupal_get_path('module', 'bibsdb_expose');
  drupal_add_js($module_path . '/scripts/packery.options.js');
}



/**
 * Wrapper function that adds the modules css.
 */
function _bibsdb_expose_add_css() {
  $path = drupal_get_path('module', 'bibsdb_expose');
  drupal_add_css($path . '/css/bibsdb_expose.css');
}